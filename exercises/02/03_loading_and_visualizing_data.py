# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "marimo",
#     "numpy==2.2.4",
#     "scipy==1.15.2",
#     "matplotlib==3.10.1",
#     "pandas==2.2.3",
# ]
# ///

# Copyright 2025 n-squared LAB @ FAU Erlangen-Nürnberg

import marimo

__generated_with = "0.12.4"
app = marimo.App()


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell
def _(mo):
    # Title
    mo.md("# EMG Signal Processing Exercise")
    return


@app.cell
def _(mo):
    # Introduction
    mo.md("""
    ## Introduction to EMG Signal Processing

    In this exercise, you will process EMG (Electromyography) signals. EMG measures the electrical activity of muscles, which is crucial for understanding muscle function and movement.

    ### Key Concepts

    #### 1. EMG Signals
    - EMG signals are electrical potentials generated by muscle fibers during contraction
    - Surface EMG (sEMG) is recorded using electrodes placed on the skin
    - The raw signal contains both the muscle activity and various types of noise

    #### 2. Data Storage (Pickle Files)
    - A pickle file (`.pkl`) is a Python-specific file format for serializing and deserializing Python objects
    - It's used to store complex data structures (like our EMG data) in a way that preserves their structure
    - Our data contains:
        - `biosignal`: The raw EMG data in a 3D array (channels × windowsize × window)
        - `ground_truth_sampling_frequency`: The rate at which the signal was recorded

    #### 3. Signal Processing Steps

    **a) Bandpass Filtering**
    - Why filter? Raw EMG signals contain noise from:
        - Power line interference (50/60 Hz)
        - Movement artifacts
        - Other biological signals
    - The Nyquist Theorem states that to accurately represent a signal, we must sample at least twice the highest frequency of interest
    - For EMG, we typically use:
        - Low cutoff: 20 Hz (removes movement artifacts and low-frequency noise)
        - High cutoff: 450 Hz (removes high-frequency noise and aliasing)

    **b) RMS (Root Mean Square)**
    - RMS is a measure of signal amplitude
    - Why use RMS?
        - EMG signals are alternating (positive and negative)
        - RMS provides a positive value representing the signal's power
        - Helps visualize muscle activation patterns
    - We use a 100ms window to calculate RMS, which:
        - Smooths the signal
        - Provides a good balance between temporal resolution and noise reduction

    #### 4. Visualization
    We'll create plots showing:

    1. Original EMG signal (raw data)
    2. Filtered signal (after bandpass filtering)
    3. RMS signal (amplitude envelope)

    This will help us understand how each processing step affects the signal and why each step is necessary.
    """)
    return


@app.cell
def _(mo):
    # Step 1: Loading the data
    mo.md("""
    ## Step 1: Loading and Understanding the Data

    First, let's load the data file and examine its structure. The data contains:

    - `biosignal`: The EMG data in a 3D array format (channels × windowsize × window)
    - `['device_information']['sampling_frequency']`: The sampling rate of the signal

    We'll need to:

    1. Load the data and examine its structure
    2. Extract the EMG signal and sampling rate
    3. Restructure the EMG data to have each channel in a separate array

    Write your code below:
    """)
    return


@app.cell
def _():
    # Code cell for loading data
    import numpy as np
    import pandas as pd

    # TODO: Load the data using pandas
    # Find the appropriate pandas function to load a pickle file
    # Store the loaded data in a variable called 'data'
    data =  None # Replace this line with your code

    # Display basic information about the data
    print("Data structure:")
    print("-" * 50)
    print(f"Data type: {type(data)}")
    print(f"Data shape: {data.shape if hasattr(data, 'shape') else 'N/A'}")
    print("\nAvailable keys in data:")
    print("-" * 50)
    for key in data.keys():
        print(f"- {key}")
    print("-" * 50)

    # TODO: Extract the EMG signal and sampling rate from the loaded data
    # 1. Extract the EMG signal from the 'biosignal' key
    # 2. Extract the sampling rate from the 'device_information' dictionary under the 'sampling_frequency' key
    emg_signal = None  # Replace this line with your code
    sampling_rate = None  # Replace this line with your code

    print("\nEMG Signal information:")
    print("-" * 50)
    print(f"Signal shape: {emg_signal.shape}")
    print(f"Number of channels: {emg_signal.shape[0]}")
    print(f"Window size: {emg_signal.shape[1]}")
    print(f"Number of windows: {emg_signal.shape[2]}")
    print(f"Sampling rate: {sampling_rate} Hz")
    return data, emg_signal, key, np, pd, sampling_rate


@app.cell
def _(mo):
    # Step 2: Restructuring the EMG Data
    mo.md("""
    ## Step 2: Restructuring the EMG Data

    Now that we understand the data structure, we need to restructure the EMG signal.
    Currently, it's in the format: channels × windowsize × window

    We need to:

    1. Reshape the data to combine all windows for each channel
    2. Create a 2D array where each row represents a channel's continuous signal

    Write your code below:
    """)
    return


@app.cell
def _(emg_signal):
    # Code cell for restructuring EMG data
    # Get the number of channels


    # TODO: Reshape the 3D array to 2D
    # First transpose to get windows × samples × channels
    # Then reshape to combine all windows for each channel
    num_channels = None
    channel_data = None

    print("\nRestructured EMG Data:")
    print("-" * 50)
    print(f"Original shape: {emg_signal.shape}")
    print(f"New shape: {channel_data.shape}")
    print(f"Number of channels: {emg_signal.shape[0]}")
    print(f"Total samples per channel: {num_channels}")
    return channel_data, num_channels


@app.cell
def _(mo):
    # Step 3: Bandpass Filtering
    mo.md("""
    ## Step 3: Bandpass Filtering

    Now, apply a bandpass filter to the EMG signal. For surface EMG, typical cutoff frequencies are:
    - Low cutoff: 20 Hz
    - High cutoff: 450 Hz

    You'll need to:

    1. Import scipy.signal
    2. Design a bandpass filter
    3. Apply it to the EMG signal

    Write your code below:
    """)
    return


@app.cell
def _(high, low, num_channels, sampling_rate):
    # Code cell for bandpass filtering
    from scipy import signal

    # TODO: Define the cutoff frequencies for the bandpass filter
    # For EMG signals, typical values are:
    # - Low cutoff: 20 Hz (removes movement artifacts and low-frequency noise)
    # - High cutoff: 450 Hz (removes high-frequency noise and aliasing)
    low_cut = None  # Replace with your code
    high_cut = None  # Replace with your code

    # TODO: Check if the frequencies adhere to the nyquist theorem
    # Raise a ValueError if the frequencies are invalid
    # Hint: Use the Nyquist frequency (sampling_rate/2)
    # Error message should explain why the frequencies are invalid
    # Example: "High cutoff frequency (450 Hz) exceeds Nyquist frequency (500 Hz)"
    nyquist = None  # Replace with your code

    print("\nFilter Design Parameters:")
    print("-" * 50)
    print(f"Sampling rate: {sampling_rate} Hz")
    print(f"Nyquist frequency: {nyquist} Hz")
    print(f"Low cutoff: {low_cut} Hz ({low:.4f} normalized)")
    print(f"High cutoff: {high_cut} Hz ({high:.4f} normalized)")

    # TODO: Design the Butterworth bandpass filter
    # Hint: Use signal.butter() with order=4 and btype='band'
    b = None  # Replace with your code
    a = None  # Replace with your code

    # TODO: Pre-allocate the filtered channels array
    # Hint: Use np.zeros() with the same shape as channel_data
    filtered_channels = None  # Replace with your code

    # TODO: Apply the filter to each channel
    # Hint: Use signal.filtfilt() to avoid phase distortion
    # Loop through each channel and apply the filter

    print("\nFiltered Signal Information:")
    print("-" * 50)
    print(f"Number of filtered channels: {num_channels}")
    print(f"Shape of filtered_channels: {filtered_channels.shape}")
    print(f"Type of filtered_channels: {type(filtered_channels)}")
    print(f"Filter cutoff frequencies: {low_cut} Hz to {high_cut} Hz")
    return a, b, filtered_channels, high_cut, low_cut, nyquist, signal


@app.cell
def _(mo):
    # Step 4: RMS Calculation
    mo.md("""
    ## Step 4: RMS Calculation

    Calculate the Root Mean Square (RMS) of the filtered signal. The RMS gives us the amplitude of the EMG signal.
    Use a window size of 100ms (convert this to samples using the sampling rate).

    Write your code below:
    """)
    return


@app.cell
def _(filtered_channels, np, num_channels, sampling_rate):
    # Code cell for RMS calculation
    
    # TODO: Calculate the window size for RMS calculation
    # Hint: Convert 100ms to samples using the sampling rate
    # Example: window_size = int(0.1 * sampling_rate)
    window_size = None  # Replace with your code

    # TODO: Pre-allocate the RMS signals array
    # Hint: Use np.zeros() with the same shape as filtered_channels
    rms_signals = None  # Replace with your code

    # TODO: Calculate RMS for each channel
    # Hint: For each channel:
    # 1. Square the signal values
    # 2. Apply a moving average using np.convolve()
    # 3. Take the square root of the result
    # Note: Use mode='same' in np.convolve() to maintain signal length
    # The formula for RMS is: sqrt(mean(signal^2))

    print("\nRMS Signal Information:")
    print("-" * 50)
    print(f"Number of channels: {num_channels}")
    print(f"Shape of RMS signals: {rms_signals.shape}")
    print(f"Window size: {window_size} samples ({window_size/sampling_rate*1000:.1f} ms)")
    return channel, rms_signals, window_size


@app.cell
def _(mo, num_channels):
    # Channel selector
    ch = mo.ui.slider(1, num_channels, value=1, label="Select Channel")
    mo.md(f"""
    ## Select Channel to Visualize

    Use the slider below to select which channel you want to visualize:
    {ch}
    """)
    return (ch,)


@app.cell
def _(ch, channel_data, filtered_channels, np, rms_signals, sampling_rate):
    # Code cell for visualization
    import matplotlib.pyplot as plt

    # Get the selected channel (convert from 1-based to 0-based indexing)
    selected_channel = ch.value -1

    # Create time array
    t = np.arange(len(channel_data[selected_channel, :])) / sampling_rate

    # Create figure with 3 subplots
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 8), sharex=True)

    # Plot original signal for selected channel
    ax1.plot(t, channel_data[selected_channel, :])
    ax1.set_title(f'Original EMG Signal - Channel {ch.value}')
    ax1.set_ylabel('Amplitude (V)')

    # Plot filtered signal for selected channel
    ax2.plot(t, filtered_channels[selected_channel, :])
    ax2.set_title(f'Bandpass Filtered Signal - Channel {ch.value}')
    ax2.set_ylabel('Amplitude (V)')

    # Plot RMS signal for selected channel
    ax3.plot(t, rms_signals[selected_channel, :])
    ax3.set_title(f'RMS Signal - Channel {ch.value}')
    ax3.set_ylabel('Amplitude (V)')
    ax3.set_xlabel('Time (s)')

    plt.tight_layout()
    plt.show()
    return ax1, ax2, ax3, fig, plt, selected_channel, t


if __name__ == "__main__":
    app.run()
